use std::{
    any::Any,
    fmt::{Debug, Display},
    sync::{Arc, LazyLock},
};

use actix_web::http::uri::PathAndQuery;
use anyhow::{anyhow, Result};
use async_trait::async_trait;
use crc::Crc;
use downcast_rs::{impl_downcast, DowncastSync};
use password::PasswordIdPConfig;
use rand::RngCore;
use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{server::IdServer, user::User};

pub mod password;

/// Numeric identifier of identity providers.
/// Generated as the CRC-16 checksum of the provider name.
#[derive(Copy, Clone, PartialEq, Eq, Hash)]
pub struct IdProviderId(u16);

static IDP_ID_CRC: LazyLock<Crc<u16>> =
    LazyLock::new(|| Crc::<u16>::new(&crc::CRC_16_ISO_IEC_14443_3_A));

impl IdProviderId {
    pub fn as_u16(&self) -> u16 {
        self.0
    }
}

impl From<&[u8]> for IdProviderId {
    fn from(value: &[u8]) -> Self {
        Self(IDP_ID_CRC.checksum(value))
    }
}

impl From<&str> for IdProviderId {
    fn from(value: &str) -> Self {
        Self::from(value.as_bytes())
    }
}

impl From<String> for IdProviderId {
    fn from(value: String) -> Self {
        Self::from(value.as_bytes())
    }
}

impl From<&IdProviderId> for u16 {
    fn from(value: &IdProviderId) -> Self {
        value.0
    }
}

impl From<u16> for IdProviderId {
    fn from(value: u16) -> Self {
        Self(value)
    }
}

impl Debug for IdProviderId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn Display).fmt(f)
    }
}

impl Display for IdProviderId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{:04x}", self.0))
    }
}

/// Identifier of identity secrets.
/// Represented as UUID Version 4 (as defined in RFC 9562).
/// However, the data are not completly randomly generated.
/// The 112-127 bits must be the identity provider ID.
/// The random bytes of UUID should be generated by CSPRNG.
#[derive(Copy, Clone, PartialEq, Eq, Hash, sqlx::prelude::Type)]
pub struct IdSecretId(pub Uuid);

impl IdSecretId {
    pub fn new(idp: IdProviderId) -> Self {
        let mut bytes = [0; 16];
        let idp = idp.0.to_be_bytes();
        bytes[..2].copy_from_slice(&idp);
        IdServer::get()
            .csrng
            .lock()
            .unwrap()
            .fill_bytes(&mut bytes[2..]);
        Self(uuid::Builder::from_random_bytes(bytes).into_uuid())
    }

    pub fn idp(&self) -> IdProviderId {
        ((self.0.as_u128() >> 112) as u16).into()
    }

    pub fn get_idp(&self) -> Result<&'static IdProvider> {
        IdServer::get()
            .providers
            .get(&self.idp())
            .ok_or_else(|| anyhow!("unknown identity provider"))
    }
}

impl From<Uuid> for IdSecretId {
    fn from(value: Uuid) -> Self {
        Self(value)
    }
}

impl Into<Uuid> for IdSecretId {
    fn into(self) -> Uuid {
        self.0
    }
}

pub trait IdSecret: Send + Sync + Any + DowncastSync {}
impl_downcast!(sync IdSecret);
impl<T: IdSecret + ?Sized> IdSecret for Box<T> {}

pub trait IdSecretExt {
    fn auth_downcast<T: IdSecret>(&self) -> AuthResult<&T>;
}
impl IdSecretExt for Box<dyn IdSecret> {
    fn auth_downcast<T: IdSecret>(&self) -> AuthResult<&T> {
        self.downcast_ref().ok_or(AuthenticationError::BadSecret)
    }
}

pub trait IdCred: Send + Sync + Any + DowncastSync {}
impl_downcast!(sync IdCred);
impl<T: IdCred + ?Sized> IdCred for Box<T> {}

pub trait IdCredExt {
    fn auth_downcast<T: IdCred>(&self) -> AuthResult<&T>;
}
impl IdCredExt for Box<dyn IdCred> {
    fn auth_downcast<T: IdCred>(&self) -> AuthResult<&T> {
        self.downcast_ref()
            .ok_or(AuthenticationError::InvalidCredential)
    }
}

pub struct IdProvider {
    pub id: IdProviderId,
    pub authentication: Option<Arc<dyn IdAuthenticationProvider>>,
    pub web_authentication: Option<Arc<dyn IdWebAuthenticationFlow>>,
    pub web_register: Option<Arc<dyn IdWebRegisterFlow>>,
}

impl Debug for IdProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Debug::fmt(&self.id, f)
    }
}

impl Display for IdProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.id, f)
    }
}

#[async_trait]
pub trait IdAuthenticationProvider: Send + Sync {
    async fn list_secrets(
        &self,
        user: Option<User>,
    ) -> AuthResult<Vec<IdSecretId>>;

    async fn fetch(
        &self,
        secret: IdSecretId,
    ) -> AuthResult<(User, Box<dyn IdSecret>)>;

    async fn authenticate(
        &self,
        user: User,
        secret_id: IdSecretId,
        secret: &Box<dyn IdSecret>,
        cred: &Box<dyn IdCred>,
    ) -> AuthResult<()>;

    async fn remove(&self, secret: IdSecretId) -> Result<()>;
}

#[async_trait]
pub trait IdWebAuthenticationFlow: Send + Sync {
    async fn begin(
        &self,
        secret: IdSecretId,
    ) -> AuthResult<Option<PathAndQuery>> {
        _ = secret;
        Ok(None)
    }
}

#[async_trait]
pub trait IdWebRegisterFlow: Send + Sync {
    async fn begin(
        &self,
        secret: IdSecretId,
    ) -> AuthResult<Option<PathAndQuery>> {
        _ = secret;
        Ok(None)
    }
}

pub type AuthResult<R> = Result<R, AuthenticationError>;

#[derive(thiserror::Error, Debug)]
pub enum AuthenticationError {
    #[error("User cancelled authentication")]
    Cancelled,
    #[error("Authentication secret not found")]
    SecretNotFound,
    #[error("Bad authentication secret")]
    BadSecret,
    #[error("Bad authentication credential")]
    BadCredential,
    #[error("Invalid authentication credential")]
    InvalidCredential,
    #[error("Credential not supported by this IdP")]
    UnsupportedCredential,
    #[error(transparent)]
    Unknown(#[from] anyhow::Error),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "kebab-case", deny_unknown_fields, tag = "type")]
pub enum IdProviderConfig {
    Password(PasswordIdPConfig),
}

pub trait IdProviderFactory: Send + Sync {
    fn to_idp(&self, id: IdProviderId) -> Result<IdProvider>;
}

impl IdProviderFactory for IdProviderConfig {
    fn to_idp(&self, id: IdProviderId) -> Result<IdProvider> {
        match &self {
            IdProviderConfig::Password(config) => config.to_idp(id),
        }
    }
}
