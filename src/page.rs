use std::collections::BTreeSet;

use anyhow::{anyhow, bail, Result};
use chrono::{DateTime, Utc};
use mwbot::generators::{AllPages, Generator};
use sea_orm::{prelude::*, ActiveValue, IntoActiveModel, QuerySelect};
use tokio::sync::Mutex;
use tracing::{error, info, info_span, trace, Instrument};
use uuid::Uuid;

use crate::{
	app::App,
	db::{self},
	site,
};

#[derive(Debug, Clone, Hash, PartialEq, Eq)]
pub struct Page(db::page::Model);

impl PartialOrd for Page {
	fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
		Some(self.cmp(other))
	}
}

impl Ord for Page {
	fn cmp(&self, other: &Self) -> std::cmp::Ordering {
		self.0.id.cmp(&other.0.id)
	}
}

static CREATION_LOCK: Mutex<()> = Mutex::const_new(());

impl Page {
	pub async fn normalize_title(lang: &str, title: &str) -> Result<String> {
		let bot = App::get().mwbot(lang).await?;
		let codec = bot.title_codec();
		Ok(codec.to_pretty(&codec.new_title(title)?))
	}

	pub fn get_lang_id(lang: &str) -> Uuid {
		Uuid::new_v5(&site::ROOT_UUID_NS, lang.as_bytes())
	}

	pub fn get_page_id(lang: &str, title: &str) -> Uuid {
		Uuid::new_v5(&Self::get_lang_id(lang), title.as_bytes())
	}

	pub async fn get_by_id(id: Uuid) -> Result<Option<Self>> {
		Ok(db::page::Entity::find_by_id(id)
			.one(db::get().as_ref())
			.await?
			.map(Page))
	}

	pub async fn get_by_name(lang: &str, title: &str) -> Result<Option<Self>> {
		Self::get_by_id(Self::get_page_id(lang, title)).await
	}

	pub async fn get_or_init(lang: &str, title: &str) -> Result<Option<Self>> {
		if let Some(page) = Self::get_by_name(lang, title).await? {
			Ok(Some(page))
		} else {
			let _ = CREATION_LOCK.lock().await;
			if let Some(page) = Self::get_by_name(lang, title).await? {
				return Ok(Some(page));
			}

			// check language and namespace allowed
			if let Some(ns) = site::ALLOWED_NAMESPACES.get(lang) {
				let bot = App::get().mwbot(lang).await?;
				let namespace = bot
					.namespace_name(bot.title_codec().new_title(title)?.namespace())
					.ok_or_else(|| anyhow!("name of NS of '{}' not found", title))?;
				if !ns.contains(namespace) {
					return Ok(None);
				}
			} else {
				return Ok(None);
			}

			let new = db::page::ActiveModel {
				id: ActiveValue::Set(Self::get_page_id(lang, title)),
				lang: ActiveValue::Set(lang.to_owned()),
				title: ActiveValue::Set(title.to_owned()),
				..Default::default()
			};
			Ok(Some(Self(new.insert(db::get().as_ref()).await?)))
		}
	}

	pub fn id(&self) -> &Uuid {
		&self.0.id
	}

	pub fn lang(&self) -> &str {
		&self.0.lang
	}

	pub fn title(&self) -> &str {
		&self.0.title
	}

	pub fn last_checked(&self) -> Option<DateTime<Utc>> {
		if self.0.last_checked == DateTime::UNIX_EPOCH {
			None
		} else {
			Some(self.0.last_checked.to_owned())
		}
	}

	pub fn check_requested_time(&self) -> Option<DateTime<Utc>> {
		self.0.need_check
	}

	pub fn issues_count(&self) -> u32 {
		self.0.issues
	}

	pub fn suggests_count(&self) -> u32 {
		self.0.suggests
	}

	pub async fn mark_check(self) -> Result<()> {
		let mut model = self.0.into_active_model();
		model.need_check = ActiveValue::Set(Some(Utc::now()));
		model.update(db::get().as_ref()).await?;
		App::get().linter_notify.notify_waiters();
		Ok(())
	}

	pub async fn set_checked(self, start_time: DateTime<Utc>, issues: u32) -> Result<()> {
		if self.check_requested_time() != Some(start_time) {
			info!(
				lang = self.lang(),
				title = self.title(),
				"drop check result for page to be checked again"
			);
			return Ok(());
		}
		let mut model = self.0.into_active_model();
		model.last_checked = ActiveValue::Set(Utc::now());
		model.need_check = ActiveValue::Set(None);
		model.issues = ActiveValue::Set(issues);
		model.update(db::get().as_ref()).await?;
		Ok(())
	}

	pub async fn delete(self) -> Result<()> {
		self.0
			.into_active_model()
			.delete(db::get().as_ref())
			.await?;
		Ok(())
	}
}

pub async fn sync_all_pages(lang: &str) -> Result<()> {
	let app = App::get();
	let bot = app.mwbot(lang).await?;
	let mut pages: BTreeSet<String> = BTreeSet::new();

	for ns in &site::ALLOWED_NAMESPACES[lang] {
		let nsid = bot
			.namespace_id(*ns)
			.ok_or_else(|| anyhow!("NS {} does not exist on {}", ns, lang))?;
		if nsid < 0 {
			bail!("NS {} on {} is special NS", ns, lang);
		}
		let mut gen = AllPages::new(nsid as u32).generate(&bot);
		while let Some(page) = gen.recv().await {
			let page = page?;
			trace!(lang, ns, %page, "syncing page");
			pages.insert(page.title().to_string());

			let ts = *page
				.touched()
				.await?
				.ok_or_else(|| anyhow!("page does not exist is generated by allpages"))?;
			let mut dbpage = Page::get_by_name(lang, page.title()).await?;
			if dbpage.is_none() {
				info!(lang, ns, %page, "find new page in allpages sync");
				dbpage = Page::get_or_init(lang, page.title()).await?;
			}
			let dbpage = dbpage.ok_or_else(|| anyhow!("allpages syncer got a disallowed page"))?;
			if let Some(t) = dbpage.last_checked() {
				if ts > t {
					info!(lang, ns, %page, "page outdated, marking for check");
					dbpage.mark_check().await?;
				}
			}
		}
	}

	let dbpages = db::page::Entity::find()
		.filter(db::page::Column::Lang.eq(lang))
		.select_only()
		.column(db::page::Column::Title)
		.all(db::get().as_ref())
		.await?;
	for dbpage in dbpages {
		if !pages.contains(&dbpage.title) {
			info!(page = dbpage.title, "remove deleted page from database");
			Page(dbpage).delete().await?;
		}
	}

	Ok(())
}

pub async fn run_page_list_syncer() {
	let app = App::get();

	loop {
		tokio::select! {
			_ = app.resync_pages_notify.notified()=>{},
			_ = tokio::time::sleep(std::time::Duration::from_secs(site::SYNC_ALL_PAGES_PEROID))=>{}
		}
		for lang in site::ALLOWED_NAMESPACES.keys() {
			if let Err(err) = sync_all_pages(lang)
				.instrument(info_span!("sync_all_pages", lang))
				.await
			{
				let err = err.context(format!("sync all pages lang={}", lang));
				error!(%err, lang, "failed to sync all pages");
			}
		}
	}
}
